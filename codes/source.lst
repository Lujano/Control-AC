CCS PCM C Compiler, Version 5.015, 5967               29-may.-18 13:01

               Filename:   F:\GitHub\Control-AC\codes\source.lst

               ROM used:   944 words (92%)
                           Largest free fragment is 80
               RAM used:   33 (49%) at main() level
                           47 (69%) worst case
               Stack used: 4 locations (3 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   1E9
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  10
0007:  SWAPF  03,W
0008:  MOVWF  11
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  10
000C:  SWAPF  03,W
000D:  MOVWF  11
000E:  BSF    11.1
000F:  MOVF   0A,W
0010:  MOVWF  17
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  10,F
0014:  MOVF   04,W
0015:  MOVWF  12
0016:  MOVF   0C,W
0017:  MOVWF  13
0018:  MOVF   0D,W
0019:  MOVWF  14
001A:  MOVF   0E,W
001B:  MOVWF  15
001C:  MOVF   0F,W
001D:  MOVWF  16
001E:  BCF    03.5
001F:  BTFSS  0B.4
0020:  GOTO   023
0021:  BTFSC  0B.1
0022:  GOTO   03A
0023:  BTFSS  0B.5
0024:  GOTO   027
0025:  BTFSC  0B.2
0026:  GOTO   070
0027:  MOVF   12,W
0028:  MOVWF  04
0029:  MOVF   13,W
002A:  MOVWF  0C
002B:  MOVF   14,W
002C:  MOVWF  0D
002D:  MOVF   15,W
002E:  MOVWF  0E
002F:  MOVF   16,W
0030:  MOVWF  0F
0031:  MOVF   17,W
0032:  MOVWF  0A
0033:  SWAPF  11,W
0034:  MOVWF  03
0035:  BCF    03.5
0036:  SWAPF  10,W
0037:  BTFSC  11.1
0038:  BSF    03.5
0039:  RETFIE
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                             // 
.................... //                             Control de Alimentaci贸n AC                     // 
.................... //                Centro de Investigaci贸n y Tecnolog铆a Electr贸nica          // 
.................... //                        (c) 2018 Luis Gabriel Lujano Chinchilla              // 
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... //                                                                             // 
.................... //             uControlador: PIC16F873A            Lenguaje: CCS C              // 
.................... //                      Xtal: 4MHz                                             // 
.................... //                                                                             // 
.................... ///////////////////////////////////////////////////////////////////////////////// 
.................... #include <16F84A.h> 
.................... //////////// Standard Header file for the PIC16F84A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F84A 
*
0088:  MOVF   2D,W
0089:  BTFSC  03.2
008A:  GOTO   0F8
008B:  MOVWF  35
008C:  MOVF   31,W
008D:  BTFSC  03.2
008E:  GOTO   0F8
008F:  ADDWF  35,F
0090:  BTFSC  03.0
0091:  GOTO   099
0092:  MOVLW  7F
0093:  SUBWF  35,F
0094:  BTFSS  03.0
0095:  GOTO   0F8
0096:  BTFSC  03.2
0097:  GOTO   0F8
0098:  GOTO   09D
0099:  MOVLW  81
009A:  ADDWF  35,F
009B:  BTFSC  03.0
009C:  GOTO   0F8
009D:  MOVF   35,W
009E:  MOVWF  0C
009F:  CLRF   0D
00A0:  CLRF   0E
00A1:  CLRF   0F
00A2:  MOVF   2E,W
00A3:  MOVWF  39
00A4:  BSF    39.7
00A5:  MOVF   2F,W
00A6:  MOVWF  38
00A7:  MOVF   30,W
00A8:  MOVWF  37
00A9:  MOVLW  18
00AA:  MOVWF  35
00AB:  CLRF   36
00AC:  BTFSS  37.0
00AD:  GOTO   0C6
00AE:  MOVF   34,W
00AF:  ADDWF  0F,F
00B0:  BTFSS  03.0
00B1:  GOTO   0B8
00B2:  INCF   0E,F
00B3:  BTFSS  03.2
00B4:  GOTO   0B8
00B5:  INCF   0D,F
00B6:  BTFSC  03.2
00B7:  BSF    36.7
00B8:  MOVF   33,W
00B9:  ADDWF  0E,F
00BA:  BTFSS  03.0
00BB:  GOTO   0BF
00BC:  INCF   0D,F
00BD:  BTFSC  03.2
00BE:  BSF    36.7
00BF:  MOVF   32,W
00C0:  MOVWF  2F
00C1:  BSF    2F.7
00C2:  MOVF   2F,W
00C3:  ADDWF  0D,F
00C4:  BTFSC  03.0
00C5:  BSF    36.7
00C6:  RLF    36,F
00C7:  RRF    0D,F
00C8:  RRF    0E,F
00C9:  RRF    0F,F
00CA:  RRF    39,F
00CB:  RRF    38,F
00CC:  RRF    37,F
00CD:  BCF    03.0
00CE:  DECFSZ 35,F
00CF:  GOTO   0AB
00D0:  MOVLW  01
00D1:  ADDWF  0C,F
00D2:  BTFSC  03.0
00D3:  GOTO   0F8
00D4:  BTFSC  0D.7
00D5:  GOTO   0DD
00D6:  RLF    39,F
00D7:  RLF    0F,F
00D8:  RLF    0E,F
00D9:  RLF    0D,F
00DA:  DECF   0C,F
00DB:  BTFSC  03.2
00DC:  GOTO   0F8
00DD:  BTFSS  39.7
00DE:  GOTO   0EE
00DF:  INCF   0F,F
00E0:  BTFSS  03.2
00E1:  GOTO   0EE
00E2:  INCF   0E,F
00E3:  BTFSS  03.2
00E4:  GOTO   0EE
00E5:  INCF   0D,F
00E6:  BTFSS  03.2
00E7:  GOTO   0EE
00E8:  RRF    0D,F
00E9:  RRF    0E,F
00EA:  RRF    0F,F
00EB:  INCF   0C,F
00EC:  BTFSC  03.2
00ED:  GOTO   0F8
00EE:  MOVF   2E,W
00EF:  MOVWF  36
00F0:  MOVF   32,W
00F1:  XORWF  36,F
00F2:  BTFSS  36.7
00F3:  GOTO   0F6
00F4:  BSF    0D.7
00F5:  GOTO   0FC
00F6:  BCF    0D.7
00F7:  GOTO   0FC
00F8:  CLRF   0C
00F9:  CLRF   0D
00FA:  CLRF   0E
00FB:  CLRF   0F
00FC:  RETURN
*
0105:  MOVLW  B6
0106:  MOVWF  0C
0107:  CLRF   0F
0108:  CLRF   0E
0109:  CLRF   0D
010A:  MOVF   2A,W
010B:  IORWF  2B,W
010C:  IORWF  2C,W
010D:  IORWF  2D,W
010E:  BTFSS  03.2
010F:  GOTO   112
0110:  CLRF   0C
0111:  GOTO   11F
0112:  BCF    03.0
0113:  BTFSC  0D.7
0114:  GOTO   11E
0115:  RLF    2A,F
0116:  RLF    2B,F
0117:  RLF    2C,F
0118:  RLF    2D,F
0119:  RLF    0F,F
011A:  RLF    0E,F
011B:  RLF    0D,F
011C:  DECFSZ 0C,F
011D:  GOTO   112
011E:  BCF    0D.7
*
0141:  MOVLW  8E
0142:  MOVWF  0C
0143:  MOVF   2E,W
0144:  MOVWF  0D
0145:  MOVF   2D,W
0146:  MOVWF  0E
0147:  CLRF   0F
0148:  MOVF   0D,F
0149:  BTFSS  03.2
014A:  GOTO   155
014B:  MOVF   0E,W
014C:  MOVWF  0D
014D:  CLRF   0E
014E:  MOVLW  08
014F:  SUBWF  0C,F
0150:  MOVF   0D,F
0151:  BTFSS  03.2
0152:  GOTO   155
0153:  CLRF   0C
0154:  GOTO   15D
0155:  BCF    03.0
0156:  BTFSC  0D.7
0157:  GOTO   15C
0158:  RLF    0E,F
0159:  RLF    0D,F
015A:  DECF   0C,F
015B:  GOTO   155
015C:  BCF    0D.7
015D:  GOTO   259 (RETURN)
015E:  MOVF   2F,W
015F:  MOVWF  36
0160:  MOVF   33,W
0161:  XORWF  36,F
0162:  BTFSS  36.7
0163:  GOTO   169
0164:  BCF    03.2
0165:  BCF    03.0
0166:  BTFSC  2F.7
0167:  BSF    03.0
0168:  GOTO   19C
0169:  MOVF   2F,W
016A:  MOVWF  36
016B:  MOVF   32,W
016C:  MOVWF  37
016D:  MOVF   2E,W
016E:  SUBWF  37,F
016F:  BTFSC  03.2
0170:  GOTO   177
0171:  BTFSS  36.7
0172:  GOTO   19C
0173:  MOVF   03,W
0174:  XORLW  01
0175:  MOVWF  03
0176:  GOTO   19C
0177:  MOVF   33,W
0178:  MOVWF  37
0179:  MOVF   2F,W
017A:  SUBWF  37,F
017B:  BTFSC  03.2
017C:  GOTO   183
017D:  BTFSS  36.7
017E:  GOTO   19C
017F:  MOVF   03,W
0180:  XORLW  01
0181:  MOVWF  03
0182:  GOTO   19C
0183:  MOVF   34,W
0184:  MOVWF  37
0185:  MOVF   30,W
0186:  SUBWF  37,F
0187:  BTFSC  03.2
0188:  GOTO   18F
0189:  BTFSS  36.7
018A:  GOTO   19C
018B:  MOVF   03,W
018C:  XORLW  01
018D:  MOVWF  03
018E:  GOTO   19C
018F:  MOVF   35,W
0190:  MOVWF  37
0191:  MOVF   31,W
0192:  SUBWF  37,F
0193:  BTFSC  03.2
0194:  GOTO   19B
0195:  BTFSS  36.7
0196:  GOTO   19C
0197:  MOVF   03,W
0198:  XORLW  01
0199:  MOVWF  03
019A:  GOTO   19C
019B:  BCF    03.0
019C:  RETURN
*
03A5:  BSF    0A.0
03A6:  BSF    0A.1
03A7:  BCF    0A.2
03A8:  ADDWF  02,F
03A9:  GOTO   233
03AA:  GOTO   3A3
03AB:  GOTO   21E
03AC:  GOTO   2C3
03AD:  GOTO   21D
03AE:  GOTO   288
03AF:  GOTO   30A
....................  
.................... #list 
....................  
.................... #fuses XT, NOWDT 
.................... #use delay (clock = 4000000) 
.................... #use standard_io(b) 
.................... #rom 0x2100 = {0x01} 
....................  // Pines 
.................... #define CONTROL     PIN_B4    //// Control del rel茅 
.................... #define Green_LED   PIN_B3    //// Indicador de sistema encendido 
.................... #define Yellow_LED  PIN_B2    //// Indicador de sistema encendido 
.................... #define Red_LED     PIN_B1    //// Indicador de suspensi贸n de corriente 
.................... #define Pulsador    PIN_B0    //// Pulsador de encendido y de ajuste de temporizaci贸n 
....................  
.................... // Variables globales 
.................... int32 time_H ; // Variable configurable para el temporizador 
.................... float time_temp; // Variable temporal para calculos en punto flotante 
.................... int1 boton_activado = 0; 
.................... int8 time_on = 1; // tiempo en minituos en el que el dispositivo permanece activo 
.................... int8 last_time_on = 1; 
.................... float tiempo_activo ; 
....................  
.................... // states del sistema 
.................... int8 state; 
.................... int8 last_state; 
.................... int1 state_chg; // el estado del sistema ha cambiado 
.................... #define CURRENT_ON 1 // El dispositivo cuenta hasta el tiempo configurado y se apaga 
.................... #define ON 2 
.................... #define OFF 3 
.................... #define CONFIG 4 // Cambio de estado en funcion de la duracion del pulso 
.................... #define WAIT 5 
.................... #define CURRENT_OFF 6 // El dispositivo cuenta hasta el tiempo configurado y se apaga 
.................... #define CONFIG_TEMP 7 //  Ajuste de temporizacin echa por el usuario. 
....................  
....................  
.................... /// Interrupciones /// 
.................... #INT_EXT 
.................... void funcion_ext_int(){ 
.................... output_toggle(PIN_B5); 
*
003A:  BSF    03.5
003B:  BCF    06.5
003C:  MOVLW  20
003D:  BCF    03.5
003E:  XORWF  06,F
....................     if (boton_activado == 0){ //Primera interrupcin por flanco de subida 
003F:  BTFSC  20.0
0040:  GOTO   06D
....................         set_timer0(0); 
0041:  CLRF   01
....................         while(get_timer0()< 150){}; // Esperar un tiempo  
0042:  MOVF   01,W
0043:  SUBLW  95
0044:  BTFSC  03.0
0045:  GOTO   042
....................         if(input(Pulsador) == 0 ) { // Si el pulsador esta todavia activo, 
0046:  BSF    03.5
0047:  BSF    06.0
0048:  BCF    03.5
0049:  BTFSC  06.0
004A:  GOTO   06D
....................             if(state == WAIT){ 
004B:  MOVF   27,W
004C:  SUBLW  05
004D:  BTFSS  03.2
004E:  GOTO   057
....................                 state = CURRENT_ON; // Cambiar directamente el estado 
004F:  MOVLW  01
0050:  MOVWF  27
....................                 output_toggle(PIN_B6); 
0051:  BSF    03.5
0052:  BCF    06.6
0053:  MOVLW  40
0054:  BCF    03.5
0055:  XORWF  06,F
....................             } 
0056:  GOTO   06D
....................             else if( (state == CURRENT_ON)  | (state == CURRENT_OFF)){ 
0057:  DECFSZ 27,W
0058:  GOTO   05A
0059:  GOTO   05C
005A:  MOVLW  00
005B:  GOTO   05D
005C:  MOVLW  01
005D:  MOVWF  3A
005E:  MOVF   27,W
005F:  SUBLW  06
0060:  BTFSC  03.2
0061:  GOTO   064
0062:  MOVLW  00
0063:  GOTO   065
0064:  MOVLW  01
0065:  IORWF  3A,W
0066:  BTFSC  03.2
0067:  GOTO   06C
....................                 state = CONFIG; 
0068:  MOVLW  04
0069:  MOVWF  27
....................                 boton_activado = 1; 
006A:  BSF    20.0
....................             } 
006B:  GOTO   06D
....................             else{ // Estado config o config temp 
....................                 boton_activado = 1; // Analizar con la funcion medir pulso  
006C:  BSF    20.0
....................             } 
....................              
....................         } 
....................     } 
....................  
.................... } 
....................  
....................  
....................  
006D:  BCF    0B.1
006E:  BCF    0A.3
006F:  GOTO   027
.................... #INT_TIMER0 
.................... void timer0(){ 
....................  time_H= time_H+1; 
0070:  MOVLW  01
0071:  ADDWF  18,F
0072:  MOVLW  00
0073:  BTFSC  03.0
0074:  MOVLW  01
0075:  ADDWF  19,F
0076:  MOVLW  00
0077:  BTFSC  03.0
0078:  MOVLW  01
0079:  ADDWF  1A,F
007A:  MOVLW  00
007B:  BTFSC  03.0
007C:  MOVLW  01
007D:  ADDWF  1B,F
....................  set_timer0(0); // Reiniciar timer 
007E:  CLRF   01
007F:  BCF    0B.2
0080:  BCF    0A.3
0081:  GOTO   027
.................... } 
....................  
....................  
.................... float real_time_s(); 
.................... float real_time_s(); 
.................... float real_time_m(); 
.................... void reset_timer(); 
.................... float medir_pulso(); 
....................  
.................... /// MAIN /// 
.................... void main () 
*
01E9:  MOVF   03,W
01EA:  ANDLW  1F
01EB:  MOVWF  03
01EC:  BCF    20.0
01ED:  MOVLW  01
01EE:  MOVWF  21
01EF:  MOVWF  22
.................... { 
....................      
....................   // Inicializacion 
....................      // Configuracion de Timer 
....................     setup_timer_0 (T0_DIV_256 ); // Modo= oscilador interno 4MHz, cuenta cada 8us 
01F0:  BSF    03.5
01F1:  MOVF   01,W
01F2:  ANDLW  C0
01F3:  IORLW  07
01F4:  MOVWF  01
....................     set_timer0(0); // Reiniciar timer 
01F5:  BCF    03.5
01F6:  CLRF   01
....................     enable_interrupts(INT_TIMER0); 
01F7:  BSF    0B.5
....................       // Configuracion de la interrupcin externa 
....................     ext_int_edge(0, H_TO_L);    // Configurar para flanco de bajada 
01F8:  BSF    03.5
01F9:  BCF    01.6
....................     enable_interrupts(int_ext); // Habilitacin de interrupcion por RB0 
01FA:  BCF    03.5
01FB:  BSF    0B.4
....................      
....................     enable_interrupts(global); 
01FC:  BSF    0B.7
....................     
....................     output_low(CONTROL); // cargar 
01FD:  BSF    03.5
01FE:  BCF    06.4
01FF:  BCF    03.5
0200:  BCF    06.4
....................     output_high(Red_LED); // cargar 
0201:  BSF    03.5
0202:  BCF    06.1
0203:  BCF    03.5
0204:  BSF    06.1
....................     output_low(Green_LED); // cargar 
0205:  BSF    03.5
0206:  BCF    06.3
0207:  BCF    03.5
0208:  BCF    06.3
....................     input(Pulsador); 
0209:  BSF    03.5
020A:  BSF    06.0
....................      
....................     boton_activado = 0; 
020B:  BCF    03.5
020C:  BCF    20.0
....................      
....................     state = CURRENT_ON; 
020D:  MOVLW  01
020E:  MOVWF  27
....................     last_state = CURRENT_ON; 
020F:  MOVWF  28
....................     time_on = read_eeprom(0); 
0210:  CLRF   09
0211:  BSF    03.5
0212:  BSF    08.0
0213:  BCF    03.5
0214:  MOVF   08,W
0215:  MOVWF  21
....................     //output_low(PIN_B4); 
....................          
....................     while(1){ 
....................         // Comienza el sistema apagado 
....................         switch(state){ 
0216:  MOVLW  01
0217:  SUBWF  27,W
0218:  ADDLW  F9
0219:  BTFSC  03.0
021A:  GOTO   3A3
021B:  ADDLW  07
021C:  GOTO   3A5
....................             case WAIT: // No hacer nada 
....................                 break; 
021D:  GOTO   3A3
....................                  
....................             case OFF: 
....................                 last_state = OFF; 
021E:  MOVLW  03
021F:  MOVWF  28
....................                 output_low(CONTROL); // Desactivar rele 
0220:  BSF    03.5
0221:  BCF    06.4
0222:  BCF    03.5
0223:  BCF    06.4
....................                 output_low(Red_LED);  
0224:  BSF    03.5
0225:  BCF    06.1
0226:  BCF    03.5
0227:  BCF    06.1
....................                 output_low(Green_LED);  
0228:  BSF    03.5
0229:  BCF    06.3
022A:  BCF    03.5
022B:  BCF    06.3
....................                 output_low(Yellow_LED);  
022C:  BSF    03.5
022D:  BCF    06.2
022E:  BCF    03.5
022F:  BCF    06.2
....................                 state = WAIT; // Esperar a que se cambie de estado 
0230:  MOVLW  05
0231:  MOVWF  27
....................                 break; 
0232:  GOTO   3A3
....................                  
....................            case CURRENT_ON: 
....................                 last_state = CURRENT_ON; 
0233:  MOVLW  01
0234:  MOVWF  28
....................                 reset_timer(); 
0235:  CALL   082
....................                 output_high(CONTROL);  // Activar rele 
0236:  BSF    03.5
0237:  BCF    06.4
0238:  BCF    03.5
0239:  BSF    06.4
....................                 output_low(Red_LED);  
023A:  BSF    03.5
023B:  BCF    06.1
023C:  BCF    03.5
023D:  BCF    06.1
....................                 output_low(Yellow_LED);  
023E:  BSF    03.5
023F:  BCF    06.2
0240:  BCF    03.5
0241:  BCF    06.2
....................                 output_high(Green_LED); 
0242:  BSF    03.5
0243:  BCF    06.3
0244:  BCF    03.5
0245:  BSF    06.3
....................                 time_on = read_eeprom(0); 
0246:  CLRF   09
0247:  BSF    03.5
0248:  BSF    08.0
0249:  BCF    03.5
024A:  MOVF   08,W
024B:  MOVWF  21
....................                 while(real_time_s() < time_on*3.0){ 
024C:  CALL   0FD
024D:  MOVF   0F,W
024E:  MOVWF  2C
024F:  MOVF   0E,W
0250:  MOVWF  2B
0251:  MOVF   0D,W
0252:  MOVWF  2A
0253:  MOVF   0C,W
0254:  MOVWF  29
0255:  CLRF   2E
0256:  MOVF   21,W
0257:  MOVWF  2D
0258:  GOTO   141
0259:  MOVF   0F,W
025A:  MOVWF  30
025B:  MOVF   0E,W
025C:  MOVWF  2F
025D:  MOVF   0D,W
025E:  MOVWF  2E
025F:  MOVF   0C,W
0260:  MOVWF  2D
0261:  CLRF   34
0262:  CLRF   33
0263:  MOVLW  40
0264:  MOVWF  32
0265:  MOVLW  80
0266:  MOVWF  31
0267:  CALL   088
0268:  MOVF   2C,W
0269:  MOVWF  31
026A:  MOVF   2B,W
026B:  MOVWF  30
026C:  MOVF   2A,W
026D:  MOVWF  2F
026E:  MOVF   29,W
026F:  MOVWF  2E
0270:  MOVF   0F,W
0271:  MOVWF  35
0272:  MOVF   0E,W
0273:  MOVWF  34
0274:  MOVF   0D,W
0275:  MOVWF  33
0276:  MOVF   0C,W
0277:  MOVWF  32
0278:  CALL   15E
0279:  BTFSS  03.0
027A:  GOTO   281
....................                     if(state!= CURRENT_ON){ 
027B:  DECFSZ 27,W
027C:  GOTO   27E
027D:  GOTO   280
....................                     state_chg = 1; 
027E:  BSF    20.1
....................                     break; 
027F:  GOTO   281
....................                     } // interrumpir estado, si este es cambiado 
0280:  GOTO   24C
....................                 } // Esperar el tiempo configurado. 
....................  
....................                 if (state_chg != 1){ // Si no se cambio el estado, volver al ciclo periodico 
0281:  BTFSC  20.1
0282:  GOTO   286
....................                  state = CURRENT_OFF; 
0283:  MOVLW  06
0284:  MOVWF  27
....................                 } 
0285:  GOTO   287
....................                 else{ 
....................                    state_chg = 0; 
0286:  BCF    20.1
....................                 } 
....................                 break; 
0287:  GOTO   3A3
....................             case CURRENT_OFF: 
....................                 last_state = CURRENT_OFF; 
0288:  MOVLW  06
0289:  MOVWF  28
....................                 reset_timer(); 
028A:  CALL   082
....................                 output_low(CONTROL); // Desactivar rele 
028B:  BSF    03.5
028C:  BCF    06.4
028D:  BCF    03.5
028E:  BCF    06.4
....................                 output_high(Red_LED);  
028F:  BSF    03.5
0290:  BCF    06.1
0291:  BCF    03.5
0292:  BSF    06.1
....................                 output_low(Yellow_LED);  
0293:  BSF    03.5
0294:  BCF    06.2
0295:  BCF    03.5
0296:  BCF    06.2
....................                 output_high(Green_LED);  
0297:  BSF    03.5
0298:  BCF    06.3
0299:  BCF    03.5
029A:  BSF    06.3
....................                 while(real_time_s() < 5.0){ // Se espera 10 segundos 
029B:  CALL   0FD
029C:  MOVF   0F,W
029D:  MOVWF  2C
029E:  MOVF   0E,W
029F:  MOVWF  2B
02A0:  MOVF   0D,W
02A1:  MOVWF  2A
02A2:  MOVF   0C,W
02A3:  MOVWF  29
02A4:  MOVF   2C,W
02A5:  MOVWF  31
02A6:  MOVF   2B,W
02A7:  MOVWF  30
02A8:  MOVF   2A,W
02A9:  MOVWF  2F
02AA:  MOVF   29,W
02AB:  MOVWF  2E
02AC:  CLRF   35
02AD:  CLRF   34
02AE:  MOVLW  20
02AF:  MOVWF  33
02B0:  MOVLW  81
02B1:  MOVWF  32
02B2:  CALL   15E
02B3:  BTFSS  03.0
02B4:  GOTO   2BC
....................                     if(state !=  CURRENT_OFF){ 
02B5:  MOVF   27,W
02B6:  SUBLW  06
02B7:  BTFSC  03.2
02B8:  GOTO   2BB
....................                         state_chg = 1; 
02B9:  BSF    20.1
....................                         break; 
02BA:  GOTO   2BC
....................                     } 
02BB:  GOTO   29B
....................                 } 
....................  
....................                 if (state_chg != 1){ // Si no se cambio el estado, volver al ciclo periodico 
02BC:  BTFSC  20.1
02BD:  GOTO   2C1
....................                  state = CURRENT_ON; 
02BE:  MOVLW  01
02BF:  MOVWF  27
....................                   
....................                 } 
02C0:  GOTO   2C2
....................                 else{ 
....................                    state_chg = 0; 
02C1:  BCF    20.1
....................                 } 
....................  
....................                 break; 
02C2:  GOTO   3A3
....................  
....................            case CONFIG: // Estado en el que se mide el tiempo pulsado y se cambia el estado del sistema  
....................                 // Medir pulso 
....................                 tiempo_activo = medir_pulso(); // Tiempo activo el pulsador, en segundos 
02C3:  CALL   19D
02C4:  MOVF   0F,W
02C5:  MOVWF  26
02C6:  MOVF   0E,W
02C7:  MOVWF  25
02C8:  MOVF   0D,W
02C9:  MOVWF  24
02CA:  MOVF   0C,W
02CB:  MOVWF  23
....................                 if (tiempo_activo < 2.0){ 
02CC:  MOVF   26,W
02CD:  MOVWF  31
02CE:  MOVF   25,W
02CF:  MOVWF  30
02D0:  MOVF   24,W
02D1:  MOVWF  2F
02D2:  MOVF   23,W
02D3:  MOVWF  2E
02D4:  CLRF   35
02D5:  CLRF   34
02D6:  CLRF   33
02D7:  MOVLW  80
02D8:  MOVWF  32
02D9:  CALL   15E
02DA:  BTFSS  03.0
02DB:  GOTO   2F0
....................                     if ((last_state == CURRENT_ON ) | (last_state== CURRENT_OFF)){ 
02DC:  DECFSZ 28,W
02DD:  GOTO   2DF
02DE:  GOTO   2E1
02DF:  MOVLW  00
02E0:  GOTO   2E2
02E1:  MOVLW  01
02E2:  MOVWF  29
02E3:  MOVF   28,W
02E4:  SUBLW  06
02E5:  BTFSC  03.2
02E6:  GOTO   2E9
02E7:  MOVLW  00
02E8:  GOTO   2EA
02E9:  MOVLW  01
02EA:  IORWF  29,W
02EB:  BTFSC  03.2
02EC:  GOTO   2EF
....................                         state = OFF; // Apagar el dispositivo 
02ED:  MOVLW  03
02EE:  MOVWF  27
....................                     } 
....................  
....................                 } 
02EF:  GOTO   309
....................                 else{ // Si se pulsa durante mas de 2 segundos, entrar a la configuracion 
....................                     state = CONFIG_TEMP; 
02F0:  MOVLW  07
02F1:  MOVWF  27
....................                     last_time_on = time_on; 
02F2:  MOVF   21,W
02F3:  MOVWF  22
....................                     write_eeprom(0, time_on); 
02F4:  MOVF   0B,W
02F5:  MOVWF  0C
02F6:  BCF    0B.7
02F7:  CLRF   09
02F8:  MOVF   21,W
02F9:  MOVWF  08
02FA:  BSF    03.5
02FB:  BSF    08.2
02FC:  MOVLW  55
02FD:  MOVWF  09
02FE:  MOVLW  AA
02FF:  MOVWF  09
0300:  BSF    08.1
0301:  BTFSC  08.1
0302:  GOTO   301
0303:  BCF    08.2
0304:  BCF    03.5
0305:  MOVF   0C,W
0306:  BTFSC  0C.7
0307:  MOVWF  0B
....................                     time_on = 0; // Reiniciar el contador de pulsos 
0308:  CLRF   21
....................                 } 
....................  
....................                 break; 
0309:  GOTO   3A3
....................              case CONFIG_TEMP: 
....................                 output_high(Yellow_LED);  
030A:  BSF    03.5
030B:  BCF    06.2
030C:  BCF    03.5
030D:  BSF    06.2
....................                 output_high(Red_LED);  
030E:  BSF    03.5
030F:  BCF    06.1
0310:  BCF    03.5
0311:  BSF    06.1
....................                 output_low(Green_LED);  
0312:  BSF    03.5
0313:  BCF    06.3
0314:  BCF    03.5
0315:  BCF    06.3
....................                 tiempo_activo = medir_pulso(); // Tiempo activo el pulsador, en segundos 
0316:  CALL   19D
0317:  MOVF   0F,W
0318:  MOVWF  26
0319:  MOVF   0E,W
031A:  MOVWF  25
031B:  MOVF   0D,W
031C:  MOVWF  24
031D:  MOVF   0C,W
031E:  MOVWF  23
....................                 if (tiempo_activo == 0.0 ) { // Si se dejo de pulsar durante 10 segundos  
031F:  MOVF   26,W
0320:  MOVWF  31
0321:  MOVF   25,W
0322:  MOVWF  30
0323:  MOVF   24,W
0324:  MOVWF  2F
0325:  MOVF   23,W
0326:  MOVWF  2E
0327:  CLRF   35
0328:  CLRF   34
0329:  CLRF   33
032A:  CLRF   32
032B:  CALL   15E
032C:  BTFSS  03.2
032D:  GOTO   34A
....................                     if (time_on == 0){  // nunca se pulso 
032E:  MOVF   21,F
032F:  BTFSS  03.2
0330:  GOTO   347
....................                         time_on = last_time_on; // Tomar la ultima configuracion 
0331:  MOVF   22,W
0332:  MOVWF  21
....................                         write_eeprom(0, time_on); 
0333:  MOVF   0B,W
0334:  MOVWF  0C
0335:  BCF    0B.7
0336:  CLRF   09
0337:  MOVF   21,W
0338:  MOVWF  08
0339:  BSF    03.5
033A:  BSF    08.2
033B:  MOVLW  55
033C:  MOVWF  09
033D:  MOVLW  AA
033E:  MOVWF  09
033F:  BSF    08.1
0340:  BTFSC  08.1
0341:  GOTO   340
0342:  BCF    08.2
0343:  BCF    03.5
0344:  MOVF   0C,W
0345:  BTFSC  0C.7
0346:  MOVWF  0B
....................                          
....................                     } 
....................                     state  = CURRENT_ON; // De lo contrario se toma el time_on hasta ahora configurado 
0347:  MOVLW  01
0348:  MOVWF  27
....................                      
....................                 } 
0349:  GOTO   3A3
....................                 else if ((tiempo_activo < 2.0) & (tiempo_activo >0.0)){ 
034A:  MOVF   26,W
034B:  MOVWF  31
034C:  MOVF   25,W
034D:  MOVWF  30
034E:  MOVF   24,W
034F:  MOVWF  2F
0350:  MOVF   23,W
0351:  MOVWF  2E
0352:  CLRF   35
0353:  CLRF   34
0354:  CLRF   33
0355:  MOVLW  80
0356:  MOVWF  32
0357:  CALL   15E
0358:  MOVLW  00
0359:  BTFSC  03.0
035A:  MOVLW  01
035B:  MOVWF  29
035C:  CLRF   31
035D:  CLRF   30
035E:  CLRF   2F
035F:  CLRF   2E
0360:  MOVF   26,W
0361:  MOVWF  35
0362:  MOVF   25,W
0363:  MOVWF  34
0364:  MOVF   24,W
0365:  MOVWF  33
0366:  MOVF   23,W
0367:  MOVWF  32
0368:  CALL   15E
0369:  MOVLW  00
036A:  BTFSC  03.0
036B:  MOVLW  01
036C:  ANDWF  29,W
036D:  BTFSC  03.2
036E:  GOTO   388
....................                     time_on = time_on +1; 
036F:  MOVLW  01
0370:  ADDWF  21,F
....................                     write_eeprom(0, time_on); 
0371:  MOVF   0B,W
0372:  MOVWF  0C
0373:  BCF    0B.7
0374:  CLRF   09
0375:  MOVF   21,W
0376:  MOVWF  08
0377:  BSF    03.5
0378:  BSF    08.2
0379:  MOVLW  55
037A:  MOVWF  09
037B:  MOVLW  AA
037C:  MOVWF  09
037D:  BSF    08.1
037E:  BTFSC  08.1
037F:  GOTO   37E
0380:  BCF    08.2
0381:  BCF    03.5
0382:  MOVF   0C,W
0383:  BTFSC  0C.7
0384:  MOVWF  0B
....................                     state = CONFIG_TEMP; // Esperar el siguiente pulso 
0385:  MOVLW  07
0386:  MOVWF  27
....................                 } 
0387:  GOTO   3A3
....................                 else{ // Si el tiempo pulsado es mayor 
....................                     if (time_on == 0){ 
0388:  MOVF   21,F
0389:  BTFSS  03.2
038A:  GOTO   3A1
....................                         time_on = last_time_on; // Por defecto, si no se configura nada 
038B:  MOVF   22,W
038C:  MOVWF  21
....................                         write_eeprom(0, time_on);// Se toma la ultima configuracin tomada 
038D:  MOVF   0B,W
038E:  MOVWF  0C
038F:  BCF    0B.7
0390:  CLRF   09
0391:  MOVF   21,W
0392:  MOVWF  08
0393:  BSF    03.5
0394:  BSF    08.2
0395:  MOVLW  55
0396:  MOVWF  09
0397:  MOVLW  AA
0398:  MOVWF  09
0399:  BSF    08.1
039A:  BTFSC  08.1
039B:  GOTO   39A
039C:  BCF    08.2
039D:  BCF    03.5
039E:  MOVF   0C,W
039F:  BTFSC  0C.7
03A0:  MOVWF  0B
....................                     } 
....................                     state  = OFF; 
03A1:  MOVLW  03
03A2:  MOVWF  27
....................  
....................                 } 
....................  
....................                 break; 
....................  
....................         } 
03A3:  GOTO   216
....................    
....................       
....................        
....................     } 
....................    
....................  
....................     
.................... } 
....................  
03A4:  SLEEP
.................... float real_time_s(){ 
....................     time_temp = time_H*0.065536;// 65536.0/1000000.0 
*
00FD:  MOVF   1B,W
00FE:  MOVWF  2D
00FF:  MOVF   1A,W
0100:  MOVWF  2C
0101:  MOVF   19,W
0102:  MOVWF  2B
0103:  MOVF   18,W
0104:  MOVWF  2A
*
011F:  MOVF   0F,W
0120:  MOVWF  30
0121:  MOVF   0E,W
0122:  MOVWF  2F
0123:  MOVF   0D,W
0124:  MOVWF  2E
0125:  MOVF   0C,W
0126:  MOVWF  2D
0127:  MOVLW  BD
0128:  MOVWF  34
0129:  MOVLW  37
012A:  MOVWF  33
012B:  MOVLW  06
012C:  MOVWF  32
012D:  MOVLW  7B
012E:  MOVWF  31
012F:  CALL   088
0130:  MOVF   0F,W
0131:  MOVWF  1F
0132:  MOVF   0E,W
0133:  MOVWF  1E
0134:  MOVF   0D,W
0135:  MOVWF  1D
0136:  MOVF   0C,W
0137:  MOVWF  1C
....................     return time_temp; 
0138:  MOVF   1C,W
0139:  MOVWF  0C
013A:  MOVF   1D,W
013B:  MOVWF  0D
013C:  MOVF   1E,W
013D:  MOVWF  0E
013E:  MOVF   1F,W
013F:  MOVWF  0F
0140:  RETURN
.................... } 
....................  
.................... float real_time_m(){  // Tiempo en minutos 
....................     time_temp= real_time_s()/60.0; 
....................     return time_temp; 
.................... } 
....................     
.................... void reset_timer(){ 
....................      time_H = 0; // Reiniciar el contador 
*
0082:  CLRF   1B
0083:  CLRF   1A
0084:  CLRF   19
0085:  CLRF   18
....................      set_timer0(0); // Reiniciar timer 
0086:  CLRF   01
0087:  RETURN
.................... } 
....................  
.................... float medir_pulso(){ 
*
019D:  BSF    29.0
....................     int1 tiempo_agotado = 1; 
....................     reset_timer(); // Reiniciar timer 
019E:  CALL   082
....................     while(real_time_s()< 10.0)  // Se espera 10 segundos a que se introduzca un pulso 
019F:  CALL   0FD
01A0:  MOVF   0F,W
01A1:  MOVWF  2D
01A2:  MOVF   0E,W
01A3:  MOVWF  2C
01A4:  MOVF   0D,W
01A5:  MOVWF  2B
01A6:  MOVF   0C,W
01A7:  MOVWF  2A
01A8:  MOVF   2D,W
01A9:  MOVWF  31
01AA:  MOVF   2C,W
01AB:  MOVWF  30
01AC:  MOVF   2B,W
01AD:  MOVWF  2F
01AE:  MOVF   2A,W
01AF:  MOVWF  2E
01B0:  CLRF   35
01B1:  CLRF   34
01B2:  MOVLW  20
01B3:  MOVWF  33
01B4:  MOVLW  82
01B5:  MOVWF  32
01B6:  CALL   15E
01B7:  BTFSS  03.0
01B8:  GOTO   1BF
....................     { 
....................         if (boton_activado == 1){ 
01B9:  BTFSS  20.0
01BA:  GOTO   1BE
....................             tiempo_agotado = 0; 
01BB:  BCF    29.0
....................             boton_activado = 0; // resetear el evento 
01BC:  BCF    20.0
....................             break; 
01BD:  GOTO   1BF
....................         } 
01BE:  GOTO   19F
....................     } 
....................       
....................     if (tiempo_agotado == 1) // Si pasaron 10 segundos sin pulsar el interruptor 
01BF:  BTFSS  29.0
01C0:  GOTO   1C7
....................     { 
....................         return 0.0; // Nunca se pulso 
01C1:  CLRF   0C
01C2:  CLRF   0D
01C3:  CLRF   0E
01C4:  CLRF   0F
01C5:  GOTO   1E8
....................     } 
01C6:  GOTO   1E8
....................     else{ // Se pulso 
....................        while(real_time_s()< 5.0){ // Pulso de duracion maxima de 5 segundos 
01C7:  CALL   0FD
01C8:  MOVF   0F,W
01C9:  MOVWF  2D
01CA:  MOVF   0E,W
01CB:  MOVWF  2C
01CC:  MOVF   0D,W
01CD:  MOVWF  2B
01CE:  MOVF   0C,W
01CF:  MOVWF  2A
01D0:  MOVF   2D,W
01D1:  MOVWF  31
01D2:  MOVF   2C,W
01D3:  MOVWF  30
01D4:  MOVF   2B,W
01D5:  MOVWF  2F
01D6:  MOVF   2A,W
01D7:  MOVWF  2E
01D8:  CLRF   35
01D9:  CLRF   34
01DA:  MOVLW  20
01DB:  MOVWF  33
01DC:  MOVLW  81
01DD:  MOVWF  32
01DE:  CALL   15E
01DF:  BTFSS  03.0
01E0:  GOTO   1E7
....................           if (input(Pulsador) == 1){ // esperar el flanco de subida del pulsador 
01E1:  BSF    03.5
01E2:  BSF    06.0
01E3:  BCF    03.5
01E4:  BTFSC  06.0
....................              break; 
01E5:  GOTO   1E7
....................           } 
01E6:  GOTO   1C7
....................        } 
....................  
....................         return real_time_s(); 
01E7:  CALL   0FD
....................     } 
01E8:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 3FF1   XT NOWDT PUT NOPROTECT

ROM data:
002100: 0001 
